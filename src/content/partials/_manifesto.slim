section#manifesto.bg-dark.py-5

  .container-lg
    .row
      .col-12.text-center
        h2.font-weight-normal.mb-0
          ' ‚ÄúOh no, why yet another framework?‚Äù
          i ü§®

        /blockquote.text-monospace.mt-3.mb-0
          | TLDR: ‚ÄúIf it takes the same time to build your app in a scalable way, why not do it?<br>And you'll save time anyway thanks to the domains we provide!‚Äù
        .h4.text-monospace.font-weight-normal.mt-4.mb-0
          | A manifesto.

  .container-lg.mt-2
    .row
      .col-12.text-justify

        ol.pl-0
          li#manifesto-ruby-rails
            h3.h5.pb-2
              | We like Rails, but it does not teach you how to write extensible code
              a.hover-link href="#manifesto-ruby-rails"
                span.icon-link aria-hidden="true"
                span.sr-only.no-select
                  | Link to this section
            p.text-muted
              a href='https://rubyonrails.org/' target='_blank'
                | Rails
              |  is interesting in many ways, but after you hit a controller, you're on your own. How the heck are you supposed to organize your code?
            p.text-muted
              ' In terms of reusability,
              a href='https://guides.rubyonrails.org/engines.html' target='_blank'
                ' Engines
              | are a significant step, but how do you write an extensible one?
            p.text-muted
              | We think many useful abstractions are missing, and that the ones provided often fall short. Sure, as with any technology, you can always make it work. But it will be time-consuming.
            p.text-muted
              ' We built
              span.text-framework-component.text-primary
                | Kit
              |  on top of Rails, and it is fully opt-in. When we can leverage what it does well, we gladly do. We use Engines, Railties, and ActiveRecord explicitly, and hide the rest behind connectors. You'll find that the reasons to interact with Rails disappear rapidly.
            p.text-muted
              ' The genuine question that led to
              span.text-framework-component.text-primary
                | Kit
              |  is: how do I write extensible code?

          li#manifesto-domains
            h3.h5.pb-2
              | Domains
              a.hover-link href="#manifesto-domains"
                span.icon-link aria-hidden="true"
                span.sr-only.no-select
                  | Link to this section
            p.text-muted
              a href='https://martinfowler.com/bliki/DomainDrivenDesign.html' target='_blank'
                ' Domain Driven Design
              ' and particularly
              a href='https://martinfowler.com/bliki/BoundedContext.html' target='_blank'
                ' Bounded Contexts
              | help a greatly to design your applications, reason about dependencies and write reusable code.
            p.text-muted
              span.text-framework-component.text-primary Kit
              |  includes several ready-to-use domains. They are fully-fledged apps containing: the business logic for a specific part of the system, a ready-to-use JSON:API app, a user-facing web-app, and user-facing admin web-app.
            p.text-muted
              | These domains can be deployed as standalone apps or included as libraries in other domains.
            p.text-muted
              a.text-framework-component.text-framework-component-kit-domain-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-domain' target='blank'
                | Kit::Domain
              |  is here to help you build your own domains.

          li#manifesto-functional-programming
            h3.h5.pb-2
              | Functional programming
              a.hover-link href="#manifesto-functional-programming"
                span.icon-link aria-hidden="true"
                span.sr-only.no-select
                  | Link to this section
            p.text-muted
              | We think one reason Rails is not that extensible stems from relying heavily on mixins & inheritance. When you want to reuse a single utility method, you often have to instantiate or compose with a complex hierarchy of objects.
            p.text-muted
              | This leads to code where the contracts are difficult to understand, and that is difficult to unit test.
            p.text-muted
              | We try to avoid some shortfalls of OOP, and separate the code from the data. This helps greatly when reasoning about mutability and what you are actually trying to accomplish.
            p.text-muted
              | We mostly use Modules with Class methods that you can call from anywhere, or plain lambdas.

          li#manifesto-railway-oriented-programming
            h3.h5.pb-2
              | Railway oriented programming
              a.hover-link href="#manifesto-railway-oriented-programming"
                span.icon-link aria-hidden="true"
                span.sr-only.no-select
                  | Link to this section
            p.text-muted
              ' This lends itself very well to
              a href='https://fsharpforfunandprofit.com/rop/' target='_blank'
                | Railway oriented programming
              |.
            p.text-muted
              a.text-framework-component.text-framework-component-kit-organizer-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-organizer' target='blank'
                | Kit::Organizer
              |  helps you to write and chain code to compose any task. Think of it as a pipe operator.

          li#manifesto-contracts
            h3.h5.pb-2
              | Contracts
              a.hover-link href="#manifesto-contracts"
                span.icon-link aria-hidden="true"
                span.sr-only.no-select
                  | Link to this section
            p.text-muted
              | Static typing is a powerful tool that will be part of Ruby 3.
            p.text-muted
              | But as a programmer, what you actually want to do is enforce constraints like "this should be a positive int, lower than 10" or "this should be an array where the second index is a string with value X".
            p.text-muted
              ' In these situations, static typing falls short: you need
              a href="https://en.wikipedia.org/wiki/Dependent_type" target='_blank'
                | dependent types
              |  (types that also include values). They often can not be solved at compile / transpile time, as the values are not known yet.
            p.text-muted
              | As a result, you end up having to use several data validation primitives: one in the language that deals with types, and one in your project to validate your data (from a form, from a function parameter, etc.).
            p.text-muted
              | We believe that there should only be one, opt-in, validation primitive.
            p.text-muted
              ' We add support for
              a href='https://en.wikipedia.org/wiki/Design_by_contract' target='_blank'
                | design by contract
              '  through
              a.text-framework-component.text-framework-component-kit-contract-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-organizer' target='blank'
                | Kit::Contract
              | .

          li#manifesto-microservices-vs-monolith
            h3.h5.pb-2
              | Micro-services VS monolith
              a.hover-link href="#manifesto-microservices-vs-monolith"
                span.icon-link aria-hidden="true"
                span.sr-only.no-select
                  | Link to this section
            p.text-muted
              ' We believe the whole micro-services VS monolith debate is meaningless: the difference should only be a production detail.
            p.text-muted
              | We use a single repo containing multiple domains and libraries, all set-up as independent gems. In effect: a monolith, where every domain is already designed as a micro-service.
            p.text-muted
              | In production, you can expose these domains as one or several apps based on your needs, it makes no difference.
            p.text-muted
              ' We mount these domains in
              b
                | app containers
              '  thanks to
              a.text-framework-component.text-framework-component-kit-appcontainer-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-app-container' target='blank'
                | Kit::AppContainer
              | .
            p.text-muted
              ' Access from the outside world and inter-domains communication is handled by
              a.text-framework-component.text-framework-component-kit-router-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-router' target='blank'
                | Kit::Router
              |  .

          li#manifesto-data
            h3.h5.pb-2
              | About data
              a.hover-link href="#manifesto-data"
                span.icon-link aria-hidden="true"
                span.sr-only.no-select
                  | Link to this section
            p.text-muted
              | We believe the data persistence layer leaks in too many applications, where it slowly becomes the app.
            p.text-muted
              | We often access a table through different models based on what they represent in a given domain (
              a href='https://mintcore.se/blog/2019/02/do-not-be-scared-of-using-the-same-table-for-different-schemas-in-ecto' target='_blank'
                ' here
              | is an example).
              / A good rule of thumb is: only have one model that has the write ownership on a given column (excluding metadata fields like `created_at`, `updated_at`, that have no real owner).
              .
            p.text-muted
              a href='https://martinfowler.com/bliki/CQRS.html' target='_blank'
                | CQRS
              |  is a great pattern to deal with the reality of using various data sources.
            p.text-muted
              | Most applications would benefit from using an immutable, append-only write store, and from using a snapshot of the current state of the data as a read store. Sadly, the tooling and vendor database support are not there yet.
            p.text-muted
              | In the meantime, we can still be explicit about what model we use for reading or writing, and what store they should hit (
              a.text-framework-component.text-framework-component-kit-config-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-config' target='blank'
                | Kit::Config
              '  makes this trivial).
              /| If you only use one database, you have lost no time, and if it needs to evolve one day, your code won't need to change much.
            p.text-muted
              | Even if the "append-only write store" can not be your data's source of truth, it can send events to external services (emailing, analytics, advertising, marketing automation, etc.), and if persisted you gain the ability to restore the system in a past state for audit.
