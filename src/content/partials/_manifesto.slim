section#manifesto.bg-dark.py-5

  .container-lg
    .row
      .col-12.text-center
        h2.font-weight-normal.mb-0
          ' ‚ÄúOh no, why yet another framework?‚Äù
          i ü§®

        /blockquote.text-monospace.mt-3.mb-0
          | TLDR: ‚ÄúIf it takes the same time to build your app in a scalable way, why not do it?<br>And you'll save time anyway thanks to the domains we provide!‚Äù
        .h4.text-monospace.font-weight-normal.mt-4.mb-0
          | A manifesto.

  .container-lg.mt-2
    .row
      .col-12.text-justify

        ol.pl-0
          li#manifesto-ruby-rails
            h3.h5.pb-2
              | We like Rails, but it does not teach you how to write extensible code
              a.hover-link href="#manifesto-ruby-rails"
                span.icon-link aria-hidden="true"
                span.sr-only
                  | Link to this section
            p.text-muted
              a href='https://rubyonrails.org/' target='_blank'
                | Rails
              |  has many interesting aspects, but after you hit a controller, you're on your own. How are you supposed to organize your code?
            p.text-muted
              a href='https://guides.rubyonrails.org/engines.html' target='_blank'
                ' Engines
              | are a great step, but how do you actually write an extensible one?
            p.text-muted
              | We think that many of the abstractions provided fall short, or are missing entirely. Sure, you can always make it work with any technology, but it is time-consuming.
            p.text-muted
              ' So
              span.text-framework-component.text-primary
                | Kit
              |  is built on top of Rails, and when we can leverage what it already does, we gladly do. We use Engines, Railties, and ActiveRecord explicitly, but the rest is hidden behind connectors. If you are already on Rails, what we provide is fully opt-in, but you'll find that the reasons to interact with Rails disappear rapidly.
            p.text-muted
              ' The real question that led to
              span.text-framework-component.text-primary
                | Kit
              |  is: how do I write extensible code?

          li#manifesto-domains
            h3.h5.pb-2
              | Domains
              a.hover-link href="#manifesto-domains"
                span.icon-link aria-hidden="true"
                span.sr-only
                  | Link to this section
            p.text-muted
              a href='https://martinfowler.com/bliki/DomainDrivenDesign.html' target='_blank'
                ' Domain Driven Design
              ' and particularly
              a href='https://martinfowler.com/bliki/BoundedContext.html' target='_blank'
                ' Bounded Contexts
              | help a great deal to design your applications, reason about dependencies and write reusable code.
            p.text-muted
              span.text-framework-component.text-primary Kit
              |  includes several ready to use domains. In our case, they are fully-fledged apps that contain: the business logic for a specific part of the system, a ready to use JSON:API app, a user-facing web-app, and user-facing admin web-app.
            p.text-muted
              | These domains can be deployed as standalone apps or included as libraries in other domains.
            p.text-muted
              a.text-framework-component.text-framework-component-kit-domain-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-domain' target='blank'
                | Kit::Domain
              |  is here to help you build your own domains.

          li#manifesto-functional-programming
            h3.h5.pb-2
              | Functional programming
              a.hover-link href="#manifesto-functional-programming"
                span.icon-link aria-hidden="true"
                span.sr-only
                  | Link to this section
            p.text-muted
              | We think one of the reasons Rails is not particularly extensible is that it relies heavily on mixins & inheritance. So if you want to reuse a single utility method, you have to buy into a hierarchy of objects that you need to compose with and instantiate in a specific way.
            p.text-muted
              | This leads to code where the contracts are difficult to understand, and that is not easy to unit test.
            p.text-muted
              | We try to avoid some shortfalls of OOP, and separate the code from the data. This helps a great deal when reasoning about mutability and what you are actually trying to accomplish.
            p.text-muted
              | We mostly use Modules with Class methods that you can call from anywhere.

          li#manifesto-railway-oriented-programming
            h3.h5.pb-2
              | Railway oriented programming
              a.hover-link href="#manifesto-railway-oriented-programming"
                span.icon-link aria-hidden="true"
                span.sr-only
                  | Link to this section
            p.text-muted
              ' This lends itself very well to
              a href='https://fsharpforfunandprofit.com/rop/' target='_blank'
                | Railway oriented programming
              |.
            p.text-muted
              a.text-framework-component.text-framework-component-kit-organizer-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-organizer' target='blank'
                | Kit::Organizer
              |  helps you to write and chain code to compose any task. Think of it as a pipe operator.

          li#manifesto-contracts
            h3.h5.pb-2
              | Contracts
              a.hover-link href="#manifesto-contracts"
                span.icon-link aria-hidden="true"
                span.sr-only
                  | Link to this section
            p.text-muted
              | Static typing is a powerful tool that will be part of Ruby 3.
            p.text-muted
              | But as a programmer, what you actually want to do is enforce constraints like "this should be a positive int, lower than 10" or "this should be an array where the second index is a string with value X".
            p.text-muted
              ' In these situations, static typing falls short, because we need
              a href="https://en.wikipedia.org/wiki/Dependent_type" target='_blank'
                | dependent types
              |  (types that also include values). They often can not be solved at compile / transpile time, because the values are not known yet.
            p.text-muted
              | As a result, you end up having to use several data validation primitives: one in the language for types, and one in your codebase for actual values (think: validating form data, checking that a function parameter as a specific value, etc.).
            p.text-muted
              | We believe that there should only be one, opt-in, validation primitive.
            p.text-muted
              ' We take inspiration from
              a href='' target='_blank'
                | design by contract
              ' , and that is what
              a.text-framework-component.text-framework-component-kit-contract-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-organizer' target='blank'
                | Kit::Contract
              |  is all about.

          li#manifesto-microservices-vs-monolith
            h3.h5.pb-2
              | Microservices VS monolith
              a.hover-link href="#manifesto-microservices-vs-monolith"
                span.icon-link aria-hidden="true"
                span.sr-only
                  | Link to this section
            p.text-muted
              ' We believe the whole microservices VS monolith debate is meaningless: in effect, the difference should purely be a production detail.
            p.text-muted
              | A powerful pattern is to use single repo with multiple domains and libraries, all registered as independent gems. In effect: a monolith, where every domain is already designed as a micro-service.
            p.text-muted
              | You can expose these domains in production as one or several apps based on your needs, it makes no difference.
            p.text-muted
              ' These domains are mounted in
              b
                | app containers
              '  thanks to
              a.text-framework-component.text-framework-component-kit-appcontainer-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-app-container' target='blank'
                | Kit::AppContainer
              | .
            p.text-muted
              ' Access from the outside world and inter-domains communication is handled by
              a.text-framework-component.text-framework-component-kit-router-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-router' target='blank'
                | Kit::Router
              |  .

          li#manifesto-data
            h3.h5.pb-2
              | About data
              a.hover-link href="#manifesto-data"
                span.icon-link aria-hidden="true"
                span.sr-only
                  | Link to this section
            p.text-muted
              | We believe the data persistence layer leaks in too many applications, where it slowly starts to become the app.
            p.text-muted
              ' With the domains approach, we favor representing the same table through
              a href='https://mintcore.se/blog/2019/02/do-not-be-scared-of-using-the-same-table-for-different-schemas-in-ecto' target='_blank'
              | different models (
              a href='https://mintcore.se/blog/2019/02/do-not-be-scared-of-using-the-same-table-for-different-schemas-in-ecto' target='_blank'
                ' here
              | is an example).
              / A good rule of thumb is: only have one model that has the write ownership on a given column (excluding metadata fields like `created_at`, `updated_at`, that have no real owner).
              .
            p.text-muted
              a href='https://martinfowler.com/bliki/CQRS.html' target='_blank'
                | CQRS
              |  is a great pattern when modeling the reality of using various data sources.
            p.text-muted
              | Most applications would greatly benefit from using an immutable append-only log for writing data, and a snapshot of the current state of that data for reading, but the tooling / vendor database support is not there yet.
            p.text-muted
              | In the meantime, we can still be explicit about what model is used for reading or writing, and what data source they should hit (
              a.text-framework-component.text-framework-component-kit-config-color-light href='https://github.com/rubykit/kit/tree/master/libraries/kit-config' target='blank'
                | Kit::Config
              '  makes this trivial).
              | If you only use one database, you have lost no time, and if it needs to evolve one day, your code won't need to change much.
            p.text-muted
              | Having an append-only write log blends has two big advantages: it can be used to send events to external services (emailing, analytics, etc.), and it gives you a way to restore the system in a specific state if you ever need to.
